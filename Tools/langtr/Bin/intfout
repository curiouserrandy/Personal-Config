#!/usr/bin/perl -w

# Copyright (C) 1999 Randall David Smith
# This file is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

($progname=$0) =~ s;^.*/;;;
$helpstring = <<"HelpString";
$progname is a program for taking in C header files and outputing 
C++ declarations/definitions corresponding to those header files. 
Arguments:
	-c <classname>		Required; class for which to output.
	-l			Output declarations; default.
	-f			Output definitions
	<interface_file_name>	Required
HelpString
;				# Tail off emacs commenting 

$usageString="$progname [-c <classname>] [-lf]";

# Parse all the arguments.
# Initialize argument flag values here.

$output_form="decl";
$classname="NONE";
ARGS: while (scalar(@ARGV) > 0 && $ARGV[0] =~ /^-/) { # For all flag args
    ($_ = shift) =~ s/^-//;	# Get just argument without -
    (/^c$/) && do {
	$classname = shift;
	next ARGS;
    };

    (/^[lf]$/) && do {
	$output_form = ($_ eq "l") ? "decl" : "defn";
	next ARGS;
    };

    # Print help if requested, recognize "--" as indicating end of flag
    # arguments, and error out on an unknown argument.
    (/^h(elp)?$/ || /^\?$/) && do { print $helpstring; exit 0; };
    /^-$/ && last;
    die "Usage: $usageString";
}

die "Classname wasn't specified\n" if ($classname eq "NONE");

# Process any non-flag arguments
die "Usage: $usageString" if (scalar(@ARGV) != 1);

# Pull in the whole file

$/ = undef;
$_ = <ARGV>;

# Get rid of various unintersting things
s;/\*[^*]*\*+([^/*][^*]*\*+)*/;;sg;
s;^#.*$;;mg;
s;\n; ;g;

$indent_level = 0;
$indent_nesting = 4;

# Output a line, with a newline suffix and $indent_level spaces prefix
sub outline {
    my (@args) = @_;

    print " " x $indent_level;
    foreach $a (@args) {
	print $a;
    }
    print "\n";
}

outline "/* WARNING: This file is automatically generated from $ARGV[0].  */";
outline "/* DO NOT EDIT.  */";
outline "";

if ($output_form eq "decl") {
    # XXX Put in warning about auto generation
    outline "class ", $classname, " {";
    $indent_level += $indent_nesting;
}

# Should now only have lines of the form
#	<ret> <routine_string> ( <arg> (,<arg>) * ); $
# Try to match one at a time

my ($return_type, $routine_name, $args);

while (($return_type, $routine_name, $args)
       = (/^\s*
	  (\w+)		# return type
	  \s+
	  (\w+)		# Routine name
	  \s*
	  \(
	  ([^\(\)]*)	# Args
	  \)\s*\;/x)) {

    die "Can't handle non swzl_error return type: $_\n"
	if ($return_type ne "swzl_error");
	
    $_ = $';

    my (@argarray);
    my ($btype, $pind, $aname, $post);
    my ($esf) = (0);

    while (($btype, $pind, $aname, $post) =
	   ($args =~ (/
		      ^\s*
		      (\w[\w\s]*)	# Base type
		      \s*
		      (\**)		# Pointer indirection
		      \s*
		      (\w+)		# argument name
		      \s*
		      ([^,]*)		# post name; hopefully nothing
		      ,?
		      /x))) {
	$pind = length($pind);	# Information preserving, and simpler
	my (%arghash);

	# To simply my life, some asserts
	die "Can't handle post value $post in $args\n" if ($post ne "");

	$args = $';

	$esf = 1 if ($aname eq "error_string");

	$btype =~ s/^\s*(\S.*\S)\s*/$1/;
	$btype =~ s/\s+/ /g;
	$arghash{'basetype'} = $btype;
	$arghash{'numind'} = $pind;
	$arghash{'name'} = $aname;
	$arghash{'post'} = $post;

	# Work out details of output type
	# C -> C++ rules:
	#	"char **" --> string &			OUT parameter
	#   "char *" --> string			IN parameter
	#	"string_array **"  ?? Lookup
	#	"const char *" --> const string &	IN parameter
	#	"const char **" --> string &		OUT parameter
	#	"int" --> "int"				IN parameter
	#	"void **" -->

	die "Don't know how to handle 3+ levels of indirection\n"
	    if ($pind >= 3);

	if ($pind == 2
	    || ($pind == 1 && $btype !~ /((const )?(char|void)|string_array)/)) {
	    $out = 1;
	} else {
	    $out = 0;
	}

	if ($btype eq "char" && $pind >= 1) {
	    $outtype = "string";
	    $outind = $pind - $out - 1;
	} elsif ($btype eq "const char" && $pind >= 1) {
	    $outtype = $out ? "string" : "const string";
	    $outind = $pind - $out - 1;
	} elsif ($btype eq "string_array" && $pind >= 1) {
	    $outtype = "stringlist";
	    $outind = $pind - $out - 1;
	} else {
	    $outtype = $btype;
	    $outind = $pind - $out;
	}

	$arghash{'outtype'} = $outtype;
	$arghash{'outind'} = $outind;
	die "Error in logic; outind $outind != 0\n"
	    if ($outind > 1 || ($outind == 1 && $outtype ne "void"));
	$arghash{'out'} = $out;

	push (@argarray, \%arghash);
    }

    # Skip the standard stuff we know about.  
    next if ($routine_name =~ /releaseString$/
	     || $routine_name =~ /releaseStringArray$/);

    outline $return_type;

    &outline((($output_form eq "defn") ? "$classname" . "::" : ""),
	     "$routine_name(");
    $indent_level += $indent_nesting;

    for ($i = 0; $i < @argarray; $i++) {
	my $arg = $argarray[$i];

	&outline($arg->{'outtype'},
		 " ",
		 "*" x $arg->{'outind'},
		 $arg->{'out'} ? " &" : "",
		 "a_",
		 $arg->{'name'},
		 ($i + 1 != @argarray) ? "," : "");
    }
	
    $indent_level -= $indent_nesting;
    outline ")", ($output_form eq "decl" ? ";" : "");

    if ($output_form eq "decl") {
	outline "";
	next;
    }

    # The remainder of this is for function declarations.
    outline "{";
    $indent_level += $indent_nesting;

    # Outline of routine:
    #	* Declaration of error return
    #	* Declaration of all string or string array out pointers
    #	  for assignment by called routine.
    #	* Calling of the routine.  Input:
    #		* string -> char *
    #		* Bomb on string array
    #     Output:
    #		* char * or string array * pass in pointer to local var.
    #		* Everything else, pass in arg directly
    #	* If error, copy out error string and release
    #	* If not error, copy out each non-error string arg and release.
    #	* Return error return

    # Error declaration
    outline "$return_type __intf_ret;";

    # We need to declare a char * or string_array * variable for
    # each such out argument, as those types are not known to our caller.
    for ($i = 0; $i < @argarray; $i++) {
	my $arg = $argarray[$i];

	if ($arg->{'out'}
	    && $arg->{'basetype'} =~ /(const )?char|string_array/) {
	    outline  $arg->{'basetype'}, " * t_",  $arg->{'name'}, ";";
	}
    }

    # Call the routine
    outline "";
    outline "__intf_ret = ", $routine_name, "(";
    $indent_level += $indent_nesting;
    for ($i = 0; $i < @argarray; $i++) {
	my $arg = $argarray[$i];
	my $end_string = ($i + 1 == @argarray) ? "" : ",";

	# Anything character or string based gets handled specially
	# Gotta cross that with in vs. out args
	if ($arg->{'basetype'} =~ /(const )?char|string_array/) {
	    if ($arg->{'out'}) {
		outline "&t_", $arg->{'name'}, $end_string;
	    } else {
		die "Can't handle string_array as IN parameter\n"
		    if ($arg->{'basetype'} =~ /string_array/);
		outline "a_", $arg->{'name'}, "->c_str()", $end_string;
	    }
	} else {
	    &outline(($arg->{'out'} ? "&" : ""), $arg->{'name'}, $end_string);
	}
    }
    $indent_level -= $indent_nesting;
    outline ");";

    # If statement branching between error and non-error cases
    outline "if (__intf_ret != SWZL_SUCCESS) {";
    $indent_level += $indent_nesting;

    # Error case; copy out error_string and release
    if ($esf) {
	outline "a_error_string = t_error_string;";
	outline "releaseString(t_error_string);";
    } else {
	outline ";";
    }

    # Else
    $indent_level -= $indent_nesting;
    outline "} else {";
    $indent_level += $indent_nesting;

    # Non-error case; copy out everything else besides error string
    # and release.
    for ($i = 0; $i < @argarray; $i++) {
	my $arg = $argarray[$i];

	if ($arg->{'out'} && $arg->{'name'} ne "error_string") {
	    if ($arg->{'basetype'} =~ /(const )?char/) {
		outline "a_", $arg->{'name'}, " = t_", $arg->{'name'}, ";";
		outline "releaseString(t_", $arg->{'name'}, ");";
	    } elsif ($arg->{'basetype'} eq "string_array") {
		&outline("for (int i = 0; i < t_", $arg->{'name'},
			 "->string_count; i++) {");
		$indent_level += $indent_nesting;
		outline "string __tstring;";
		outline "__tstring = t_", $arg->{'name'}, "->array[i];";
		outline "a_", $arg->{'name'}, "->push_back(__tstring);";
		$indent_level -= $indent_nesting;
		outline "}";
		outline "releaseStringArray(t_", $arg->{'name'}, ");";
	    }
	    # Everything else should have been taken care of directly
	}
    }

    # Return error return and end routine.
    $indent_level -= $indent_nesting;
    outline "}";
    outline "return __intf_ret;";
    $indent_level -= $indent_nesting;
    outline "}";
    outline "";
}
	    
if ($output_form eq "decl") {
    $indent_level -= $indent_nesting;
    print " " x $indent_level;
    print "};\n";
}

die "Couldn't parse trailing input: $_\n" if /\S/;

	  


