#!/usr/bin/env python 
# At least on the mac, I really don't trust python to be in a consistent 
# place, so I'm using the path.

import os.path
import sys
from optparse import OptionParser
import csv
import urllib
import re

enable_debugging = 0

(program_directory, program_name) = os.path.split(sys.argv[0])
help_string = """
%s is a program to automatically snarf bugs from the chromium issues 
tracker and produce a spreadsheet grouping them by grouping issue.
""" % program_name

usage_string = "%s [-o <output_file_prefix>]"

parser = OptionParser(description=help_string, usage=usage_string)
parser.add_option("-?", action="help")
parser.add_option("-D", "--debug", help="Enable script debugging",
                  type="int", dest="debug", default=0, metavar="DBGLVL")
parser.add_option("-o", dest="outfile", help="Output file Prefix",
                  default="rollup")

## Further options here; template follows.  
## All args are optional; if action is store_true/false, no extra
## args are consumed.
## parser.add_option({opts-short or long}, ..., dest={}, help={},
##		     type={}, default={}, metavar={},
##		     nargs={}, choices={}, callback={}, 

(options, args) = parser.parse_args()

# Process any non-flag arguments
if len(args) > 0:
    print >> sys.stderr, "Expected usage: %s" % usage_string
    sys.exit(2)

# TDOD: CSV mods
url_template = ("http://code.google.com/p/chromium/issues/csv?" +
                "can=2&q=%s&sort=%s&colspec=%s")

cols=('ID', 'Stars', 'Pri', 'Type', 'Status', 'Summary', 
      'Owner', 'Mstone', 'OS', 'BlockedOn', 'Blocking')
sort_cols=('Blocking', 'BlockedOn', 'ID')
query="Feature=Downloads"

url = url_template % (query, "+".join(sort_cols), "+".join(cols))

## Put everything into issue_dict
issue_dict = {}
in_first_row = True
line_count = 0
# Using reader rather than DictReader because of a bug in DictReader;
# I was getting keys with the name "OwnerMstone", which was bogus.
for l in csv.reader(urllib.urlopen(url)):
    line_count += 1
    if in_first_row:
        header_fields = l
        in_first_row = False
        continue
    if not l: continue                  # Blank line

    ldict = dict(zip(header_fields, l))

    ## Convert appropriate to integer
    for key in ('ID', 'Stars'):
        ldict[key] = int(ldict[key])
    for key in ('BlockedOn', 'Blocking'):
        ldict[key] = [int(y) for y in ldict[key].split(",") if y]

    id = ldict['ID']
    ## Enter into full issue dict
    issue_dict[id] = ldict

## Get some important summary stats
grouping_issues = frozenset(
    [id for id in issue_dict
     if issue_dict[id]['Summary'] .find('(grouping issue)') != -1])

## Write it all out
outfile = open(options.outfile + ".csv", 'w')
csvwriter = csv.writer(outfile)
csvwriter.writerow(("", "Warning: This spreadsheet is periodically overwritten.",))
csvwriter.writerow(("","If you need permanent access to the data here, please make a copy.",))
csvwriter.writerow(("",))

def format_cell(col, contents):
    if col == 'ID':
        return '=hyperlink("http://crbug.com/%d"; "%d")' % (contents, contents)
    elif col == 'Blocking' or col == 'Blocked':
        if len(contents) == 0:
            return ''
        elif len(contents) == 1:
            return str(contents[0])
        else:
            return '"' + ", ".join(map(str, contents)) + '"'
    else:
        return contents

def output_issues(csvwriter, title, output_cols, from_dict, issues):
    if len(issues) == 0: return
    csvwriter.writerow((title,))
    csvwriter.writerow(output_cols)
    for id in issues:
        idict = issue_dict[id]
        csvwriter.writerow([format_cell(c, idict[c]) if fd else ""
                            for (c,fd) in zip(output_cols,from_dict)])
    csvwriter.writerow(("",))


def output_issues_from_dict(csvwriter, title, output_cols, from_dict,
                           issue_filter, sort_fn = lambda a,b: cmp(a,b)):

    issues = [id for id in issue_dict if issue_filter(issue_dict[id])]
    issues.sort(sort_fn)
    output_issues(csvwriter, title, output_cols, from_dict, issues)

global_output_cols = ("ID", "Summary", "Blocking", "Status", "Mstone", "Stars",
                      "Randy Rec", "Jeff Rec", "Notes")
global_from_dict = (True, True, True, True, True, True, False, False, False)

## Issues that aren't blocking a grouping issue.
output_issues_from_dict(csvwriter, "Orphaned issues", global_output_cols,
                        global_from_dict,
                        lambda a: not (a['ID'] in grouping_issues or
                                       grouping_issues.intersection(a['Blocking'])))

## Untriaged issues
output_issues_from_dict(csvwriter, "Untriaged Issues", global_output_cols,
                        global_from_dict,
                        lambda a: a['Status'] == "Untriaged")

## High star issues
output_issues(csvwriter, "High Star Issues", global_output_cols,
              global_from_dict,
              
              sorted(issue_dict.keys(),
                     lambda a,b: cmp(issue_dict[a]["Stars"],
                                     issue_dict[b]["Stars"]),
                     None,
                     True)[:10])
